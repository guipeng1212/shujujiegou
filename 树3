#include <stdio.h>
#include <stdlib.h>
#include <Math.h>
typedef struct Bstnode {
	int data;
	struct Bstnode* left;
	struct Bstnode* right;
}Bstnode;

struct Bstnode* root;

struct Bstnode* Getnode(int data) {
	struct Bstnode* temp = (struct Bstnode*)malloc(sizeof(struct Bstnode));
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}


Bstnode* Insert(Bstnode* root, int data) {
	if (root == NULL) {

		root = Getnode(data); //把root设置成新节点的值
		return root;
	}
	else if (data <= root->data) {
		root->left = Insert(root->left, data);//向左递归
	}   //到了深度三：比如插入25,25<15(root),向右,25>20,向左,此时的传入函数的root->left值为NULL,
		//所以调用第一个if,创建一个内存空间，然后依次返回,再把root还原到原来的位置。
	else {
		root->right = Insert(root->right, data);//向右递归
	}
	return root;
}

int FoundHight(Bstnode* temp) {
	if (temp == NULL) {
		return -1;
	}
	else return fmax(FoundHight(temp->left), FoundHight(temp->right))+1;
	// 通过不停的递归，从根节点开始，分别向左右探索，每遇到分支都分为两个方向探索，直到其中一个为叶子节点，返回-1，
	// 同时，每次“归”回时，都+1，然后等待另外一个节点探索触底，返回，两者再进行比较，返回最大的那一个的值，就是高度
}

int main() {
	root = NULL;
	root = Insert(root, 15);
	struct Bstnode* temp = root;
	root = Insert(root, 20);
	root = Insert(root, 18);
	root = Insert(root, 25);
	root = Insert(root, 12);
	root = Insert(root, 11);
	root = Insert(root, 24);
	printf("树的高度为：%d\n", FoundHight(temp));
}
